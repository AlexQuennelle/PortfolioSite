<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Voxel Loader</title>
    <link rel="stylesheet" href="../../style.css" />

    <!-- highlight.js -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11/styles/github.min.css"
      media="(prefers-color-scheme: light)"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11/styles/github-dark.min.css"
      media="(prefers-color-scheme: dark)"
    />
    <style>
      pre.code-wrapper {
        padding: 0;
      }
    </style>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <!-- Initialize highlight.js -->
  </head>
  <header>
    <nav>
      <a href="../../index.html">Home</a>
      <!-- Link back to the main index -->
    </nav>
    <h1>Voxel Loader</h1>
    <script src="../../style.js"></script>
  </header>
  <main>
    <section>
      <figure>
        <iframe
          src="VoxelLoader_1.0_web/VoxelLoader.html"
          loading="lazy"
          scrolling="no"
          style="border: none"
          id="frame"
          onload="accessiFrameContent()"
        ></iframe>
        <script></script>
        <figcaption>
          Click and drag to rotate, refresh page for a different model
        </figcaption>
        </figure>
        </section>
        <section id="desc">
          <h2>Description</h2>
        </section>
        <section class="stretch">
          <h2>Source Code</h2>
          <div class="tab">
            <button class="tablinks lang" onclick="openTab(event, 'cmakelists', 'lang')">
              CmakeLists.txt
            </button>
            <button class="tablinks lang" onclick="openTab(event, 'C++', 'lang')">C++</button>
          </div>
          <div class="tabcontent lang" id="cmakelists">
            <h3>cmakelists</h3>
<pre><code>cmake_minimum_required(VERSION 3.30.5)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# export compile commands for clang
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)

if("${CMAKE_GENERATOR}" STREQUAL "Visual Studio 17 2022")
  message("Visual Studio Generator")
else()
  set(CMAKE_CXX_FLAGS "-Wall -Wextra")
endif()
add_compile_options("$<$<COMPILE_LANGUAGE:CXX>:-O3;-ffast-math>")

# Change this to match the name of the current folder
project(VoxelLoader LANGUAGES CXX C VERSION 1.0)
option(BUILD_SHARED_LIBS "Build shared libraries" OFF)

message("Build type: ${CMAKE_BUILD_TYPE}")

set(RAYLIB_VERSION 5.5)
find_package(raylib ${RAYLIB_VERSION} QUIET) # QUIET or REQUIRED
if (NOT raylib_FOUND) # If there's none, fetch and build raylib
  include(FetchContent)
  FetchContent_Declare(
    raylib
    DOWNLOAD_EXTRACT_TIMESTAMP OFF
    URL https://github.com/raysan5/raylib/archive/refs/tags/${RAYLIB_VERSION}.tar.gz
  )
  FetchContent_GetProperties(raylib)
  if (NOT raylib_POPULATED) # Have we downloaded raylib yet?
    set(FETCHCONTENT_QUIET NO)
    FetchContent_MakeAvailable(raylib)
    set(BUILD_EXAMPLES OFF CACHE BOOL "" FORCE) # don't build the supplied examples
  endif()
endif()

file(GLOB_RECURSE MY_SOURCES CONFIGURE_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/Src/*.cpp")

add_executable("${CMAKE_PROJECT_NAME}") 
if(EMSCRIPTEN)
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --shell-file ${CMAKE_CURRENT_SOURCE_DIR}/Src/template.html")
  # set_target_properties(${CMAKE_PROJECT_NAME} PROPERTIES OUTPUT_NAME "index")
  file(GLOB_RECURSE MODELS CONFIGURE_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/Resources/*.vox")
  foreach(MODEL ${MODELS})
    get_filename_component(TRIMMED ${MODEL} NAME)
    set_target_properties(
      ${CMAKE_PROJECT_NAME} PROPERTIES LINK_FLAGS
      "--preload-file ../Resources/${TRIMMED}@./Resources/${TRIMMED}"
    )
  endforeach()
  set(CMAKE_EXECUTABLE_SUFFIX ".html")
  set_target_properties(
    ${CMAKE_PROJECT_NAME} PROPERTIES LINK_FLAGS
    "--preload-file ../Resources@./Resources"
  )
endif()
target_compile_definitions(
  ${CMAKE_PROJECT_NAME}
  PUBLIC
  $<$<CONFIG:Release>:PRODUCTION_BUILD>
  NAME="${CMAKE_PROJECT_NAME}"
)

set_target_properties("${CMAKE_PROJECT_NAME}" PROPERTIES
            RUNTIME_OUTPUT_DIRECTORY_DEBUG
            "${CMAKE_CURRENT_SOURCE_DIR}/Bin"
            RUNTIME_OUTPUT_DIRECTORY_RELEASE
            "${CMAKE_CURRENT_SOURCE_DIR}/Bin/${CMAKE_PROJECT_NAME}_${CMAKE_PROJECT_VERSION}"
)
if(EMSCRIPTEN)
  set_target_properties(
    ${CMAKE_PROJECT_NAME} PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY_RELEASE
    "${CMAKE_CURRENT_SOURCE_DIR}/Bin/${CMAKE_PROJECT_NAME}_${CMAKE_PROJECT_VERSION}_web"
  )
endif()

target_compile_definitions(
  ${CMAKE_PROJECT_NAME}
  PUBLIC
  RESOURCES_PATH=$<IF:$<CONFIG:Release>,"./Resources/","${CMAKE_CURRENT_SOURCE_DIR}/Resources/">
)

target_compile_features("${CMAKE_PROJECT_NAME}" PRIVATE cxx_std_20)

target_sources("${CMAKE_PROJECT_NAME}" PRIVATE ${MY_SOURCES} )

target_link_libraries(${PROJECT_NAME} raylib)

target_include_directories("${CMAKE_PROJECT_NAME}" PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/Include/")
target_include_directories("${CMAKE_PROJECT_NAME}" PUBLIC "${PROJECT_BINARY_DIR}")

if(NOT EMSCRIPTEN)
  add_custom_command(
  TARGET ${CMAKE_PROJECT_NAME}
  POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy_directory
  "${CMAKE_CURRENT_SOURCE_DIR}/Resources"
  $<IF:$<CONFIG:Release>,"${CMAKE_CURRENT_SOURCE_DIR}/Bin/${CMAKE_PROJECT_NAME}_${CMAKE_PROJECT_VERSION}/Resources/","${CMAKE_CURRENT_SOURCE_DIR}/Resources/">
  )
endif()</code></pre>
          </div>
          <div class="tabcontent lang" id="C++">
            <h3>C++</h3>
            <div>
              <button
                class="tablinks file"
                onclick="openTab(event, 'main', 'file')"
              >main.cpp</button>
              <button
                class="tablinks file"
                onclick="openTab(event, 'model', 'file')"
              >model.cpp</button>
              <button
                class="tablinks file"
                onclick="openTab(event, 'volume', 'file')"
              >volume.cpp</button>
            </div>
            <div class="tabcontent file" id="main">
<pre class="language-cpp cpp"><code>#include "model.h"
#include "volume.h"

#include &ltalgorithm>
#include &ltcmath>
#include &ltcstring>
#include &ltfilesystem>
#include &ltiostream>
#include &ltnumbers>
#include &ltraylib.h>
#include &ltraymath.h>
#include &ltstring>
#if defined(PLATFORM_WEB)
#include &ltemscripten/emscripten.h>
#include &ltrandom>
#endif //  defined ()

void Update();

Camera cam;
vxl::Model* model;
Vector2 camSpeed;

int main()
{
#if defined(PLATFORM_WEB)
    std::string fileName;
    std::random_device rnd;
    std::mt19937 gen(rnd());
    {
        namespace fs = std::filesystem;
        std::vector&ltstd::string> files;
        for (const auto& entry : fs::directory_iterator(RESOURCES_PATH))
        {
            files.push_back(
                entry.path().string().erase(0, strlen(RESOURCES_PATH)));
        }
        std::cout &lt&lt files.size() &lt&lt '\n';
        std::uniform_int_distribution&lt> random(0, files.size() - 1);
        fileName = files[random(gen)];
    }

    InitWindow(400, 400, NAME);
#else
    std::cout &lt&lt "Chose a file to load\n\n";
    {
        namespace fs = std::filesystem;
        for (const auto& entry : fs::directory_iterator(RESOURCES_PATH))
        {
            std::string name =
                entry.path().string().erase(0, strlen(RESOURCES_PATH));
            std::cout &lt&lt '\t' &lt&lt name &lt&lt '\n';
        }
    }
    std::string fileName;
    std::cout &lt&lt '\n';
    std::cout &lt&lt "Enter file name: ";
    std::cin >> fileName;

    // TODO: make this fancier later
    if (!std::filesystem::exists(RESOURCES_PATH + fileName))
    {
        std::cout &lt&lt RESOURCES_PATH &lt&lt fileName &lt&lt " does not exist\n";
        return -1;
    }

    InitWindow(800, 800, NAME);
#endif
    model = new vxl::Model(RESOURCES_PATH + fileName);

    float vFOV = 45.0f;
    float aspectRatio = static_cast&ltfloat>(GetScreenWidth()) /
                        static_cast&ltfloat>(GetScreenHeight());
    std::cout &lt&lt "Aspect Ratio: " &lt&lt aspectRatio &lt&lt '\n';
    float fov =
        std::min(vFOV, RAD2DEG * (2 * std::atan(std::tan((DEG2RAD * vFOV) / 2) *
                                                aspectRatio)));
    std::cout &lt&lt "FOV: " &lt&lt fov &lt&lt '\n';
    auto mBounds = Vector3(model->frames[0].bounds.x, model->frames[0].bounds.y,
                           model->frames[0].bounds.z);
    float rad =
        sqrt((pow(mBounds.x, 2) + pow(mBounds.y, 2)) + pow(mBounds.z, 2)) / 2;
    std::cout &lt&lt "Radius: " &lt&lt rad &lt&lt '\n';
    float dist = rad * (std::sin(DEG2RAD * 90) / std::sin(DEG2RAD * (fov / 2)));
    std::cout &lt&lt "Distance: " &lt&lt dist &lt&lt '\n';
    camSpeed = {.x = 0.36f - std::pow(dist * (1.0f / 25000.0f), 1.0f / 3.5f),
                .y = 0.97f - std::pow(dist * 1.0f / 500.0f, 1.0f / 5.0f)};
    std::cout &lt&lt "Camera rotation speed: (" &lt&lt camSpeed.x &lt&lt ", " &lt&lt camSpeed.y
              &lt&lt ")\n";

    {
        using namespace std::numbers;
        cam = *new Camera({.position = Vector3RotateByAxisAngle(
                               Vector3RotateByAxisAngle({dist, 0.0f, 0.0f},
                                                        {0.0f, 0.0f, 1.0f},
                                                        pi_v&ltfloat> / 12.0f),
                               {0.0f, 1.0f, 0.0f}, pi_v&ltfloat> / 4.0f),
                           .target = {0.0f, 0.0f, 0.0f},
                           .up = {0.0f, 1.0f, 0.0f},
                           .fovy = vFOV,
                           .projection = 0});
    }

#if defined(PLATFORM_WEB)
    emscripten_set_main_loop(Update, 0, 1);
#else
    SetTargetFPS(60);

    while (!WindowShouldClose())
    {
        Update();
    }
#endif

    delete model;
    CloseWindow();

    return 0;
}

void Update()
{
    float dt = GetFrameTime();
    if (IsMouseButtonDown(MOUSE_BUTTON_LEFT))
    {
        Vector2 mouseDelta{GetMouseDelta()};

        cam.position = Vector3RotateByAxisAngle(
            cam.position, {0.0f, 1.0f, 0.0f}, -mouseDelta.x * camSpeed.x * dt);
        float dAngle = -mouseDelta.y * camSpeed.y * dt;
        float currentAngle =
            Vector3Angle(Vector3Normalize(cam.position), {0.0f, 1.0f, 0.0f});
        if (currentAngle + dAngle > 175.0f * DEG2RAD)
        {
            dAngle -= (currentAngle + dAngle) - (175.0f * DEG2RAD);
        }
        else if (currentAngle + dAngle &lt 5.0f * DEG2RAD)
        {
            dAngle += (5.0f * DEG2RAD) - (currentAngle + dAngle);
        }
        cam.position = Vector3RotateByAxisAngle(
            cam.position,
            Vector3CrossProduct(
                Vector3Subtract({0.0f, 0.0f, 0.0f}, cam.position),
                {0.0f, 1.0f, 0.0f}),
            dAngle);
    }

    BeginDrawing();

    ClearBackground({100, 149, 237, 255});
    BeginMode3D(cam);

    vxl::DrawVolume(model);

    EndMode3D();
    DrawFPS(0, 0);
    EndDrawing();
}</code></pre>
        </div>
        <div class="tabcontent file" id="model">
<pre><code>#include "model.h"

#include &ltalgorithm>
#include &ltarray>
#include &ltcstdint>
#include &ltcstdlib>
#include &ltcstring>
#include &ltfstream>
#include &ltios>
#include &ltiosfwd>
#include &ltiostream>
#include &ltstring>
#include &ltvector>
#if defined(APLATFORM_DESKTOP)
namespace win
{
#include &ltwindows.h>
#include &ltwinnt.h>
#include &ltwinscard.h>
} //namespace win
#endif // _WIN32

namespace vxl
{
using std::ios;

#define FOREGROUND_WHITE 0xf
#define FOREGROUND_GREY 0x7
#define FOREGROUND_YELLOW 0xe

#define BOUNDINGBOX 0x455A4953
#define VOXELDATA 0x495A5958
#define ANIMDATA 0x4B434150
#define RGBA 0x41424752

std::array<uint32_t, 256> default_palette = {
    0x00000000, 0xffffffff, 0xffccffff, 0xff99ffff, 0xff66ffff, 0xff33ffff,
    0xff00ffff, 0xffffccff, 0xffccccff, 0xff99ccff, 0xff66ccff, 0xff33ccff,
    0xff00ccff, 0xffff99ff, 0xffcc99ff, 0xff9999ff, 0xff6699ff, 0xff3399ff,
    0xff0099ff, 0xffff66ff, 0xffcc66ff, 0xff9966ff, 0xff6666ff, 0xff3366ff,
    0xff0066ff, 0xffff33ff, 0xffcc33ff, 0xff9933ff, 0xff6633ff, 0xff3333ff,
    0xff0033ff, 0xffff00ff, 0xffcc00ff, 0xff9900ff, 0xff6600ff, 0xff3300ff,
    0xff0000ff, 0xffffffcc, 0xffccffcc, 0xff99ffcc, 0xff66ffcc, 0xff33ffcc,
    0xff00ffcc, 0xffffcccc, 0xffcccccc, 0xff99cccc, 0xff66cccc, 0xff33cccc,
    0xff00cccc, 0xffff99cc, 0xffcc99cc, 0xff9999cc, 0xff6699cc, 0xff3399cc,
    0xff0099cc, 0xffff66cc, 0xffcc66cc, 0xff9966cc, 0xff6666cc, 0xff3366cc,
    0xff0066cc, 0xffff33cc, 0xffcc33cc, 0xff9933cc, 0xff6633cc, 0xff3333cc,
    0xff0033cc, 0xffff00cc, 0xffcc00cc, 0xff9900cc, 0xff6600cc, 0xff3300cc,
    0xff0000cc, 0xffffff99, 0xffccff99, 0xff99ff99, 0xff66ff99, 0xff33ff99,
    0xff00ff99, 0xffffcc99, 0xffcccc99, 0xff99cc99, 0xff66cc99, 0xff33cc99,
    0xff00cc99, 0xffff9999, 0xffcc9999, 0xff999999, 0xff669999, 0xff339999,
    0xff009999, 0xffff6699, 0xffcc6699, 0xff996699, 0xff666699, 0xff336699,
    0xff006699, 0xffff3399, 0xffcc3399, 0xff993399, 0xff663399, 0xff333399,
    0xff003399, 0xffff0099, 0xffcc0099, 0xff990099, 0xff660099, 0xff330099,
    0xff000099, 0xffffff66, 0xffccff66, 0xff99ff66, 0xff66ff66, 0xff33ff66,
    0xff00ff66, 0xffffcc66, 0xffcccc66, 0xff99cc66, 0xff66cc66, 0xff33cc66,
    0xff00cc66, 0xffff9966, 0xffcc9966, 0xff999966, 0xff669966, 0xff339966,
    0xff009966, 0xffff6666, 0xffcc6666, 0xff996666, 0xff666666, 0xff336666,
    0xff006666, 0xffff3366, 0xffcc3366, 0xff993366, 0xff663366, 0xff333366,
    0xff003366, 0xffff0066, 0xffcc0066, 0xff990066, 0xff660066, 0xff330066,
    0xff000066, 0xffffff33, 0xffccff33, 0xff99ff33, 0xff66ff33, 0xff33ff33,
    0xff00ff33, 0xffffcc33, 0xffcccc33, 0xff99cc33, 0xff66cc33, 0xff33cc33,
    0xff00cc33, 0xffff9933, 0xffcc9933, 0xff999933, 0xff669933, 0xff339933,
    0xff009933, 0xffff6633, 0xffcc6633, 0xff996633, 0xff666633, 0xff336633,
    0xff006633, 0xffff3333, 0xffcc3333, 0xff993333, 0xff663333, 0xff333333,
    0xff003333, 0xffff0033, 0xffcc0033, 0xff990033, 0xff660033, 0xff330033,
    0xff000033, 0xffffff00, 0xffccff00, 0xff99ff00, 0xff66ff00, 0xff33ff00,
    0xff00ff00, 0xffffcc00, 0xffcccc00, 0xff99cc00, 0xff66cc00, 0xff33cc00,
    0xff00cc00, 0xffff9900, 0xffcc9900, 0xff999900, 0xff669900, 0xff339900,
    0xff009900, 0xffff6600, 0xffcc6600, 0xff996600, 0xff666600, 0xff336600,
    0xff006600, 0xffff3300, 0xffcc3300, 0xff993300, 0xff663300, 0xff333300,
    0xff003300, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000,
    0xff0000ee, 0xff0000dd, 0xff0000bb, 0xff0000aa, 0xff000088, 0xff000077,
    0xff000055, 0xff000044, 0xff000022, 0xff000011, 0xff00ee00, 0xff00dd00,
    0xff00bb00, 0xff00aa00, 0xff008800, 0xff007700, 0xff005500, 0xff004400,
    0xff002200, 0xff001100, 0xffee0000, 0xffdd0000, 0xffbb0000, 0xffaa0000,
    0xff880000, 0xff770000, 0xff550000, 0xff440000, 0xff220000, 0xff110000,
    0xffeeeeee, 0xffdddddd, 0xffbbbbbb, 0xffaaaaaa, 0xff888888, 0xff777777,
    0xff555555, 0xff444444, 0xff222222, 0xff111111};

std::ostream& operator<<(std::ostream& os, Vector3Int vec)
{
    os &lt< '(' << static_cast<uint32_t>(vec.x) << ", "
       &lt< static_cast<uint32_t>(vec.y) << ", " << static_cast<uint32_t>(vec.z)
       &lt< ')';
    return os;
}
std::ostream& operator<<(std::ostream& os, Vector4Int vec)
{
    os &lt< '(' << static_cast<uint32_t>(vec.x) << ", "
       &lt< static_cast<uint32_t>(vec.y) << ", " << static_cast<uint32_t>(vec.z)
       &lt< ", " << static_cast<uint32_t>(vec.i) << ')';
    return os;
}

Model::Model(const std::string& filePath)
{
#if defined(APLATFORM_DESKTOP)
    using win::HANDLE;
    HANDLE hConsole = win::GetStdHandle(((win::DWORD)-11));
#endif

    std::streampos fSize;
    char* fileData;

    //attempt to open file
    std::ifstream file(filePath.c_str(), ios::in | ios::binary | ios::ate);
#if defined(APLATFORM_DESKTOP)
    win::SetConsoleTextAttribute(hConsole, FOREGROUND_YELLOW);
#endif
    std::cout &lt< '\n' << "Loading ";
#if defined(APLATFORM_DESKTOP)
    win::SetConsoleTextAttribute(hConsole, FOREGROUND_GREY);
#endif
    std::cout &lt< "\"" << filePath << "\"" << '\n';
    if (file.is_open())
    {
#if defined(APLATFORM_DESKTOP)
        win::SetConsoleTextAttribute(hConsole, FOREGROUND_YELLOW);
#endif

        this->palette = default_palette;

        //load file into memory
        fSize = file.tellg();
        fileData = new char[fSize];
        file.seekg(0, ios::beg);
        file.read(fileData, fSize);
        file.close();

        //copy file ID into model
        std::copy(fileData, fileData + 4, this->ID.begin());
        std::memcpy(&this->version, &fileData[4], 4);

        std::cout &lt< this->ID << "file found:" << '\n';
        std::cout &lt< "Version: ";
#if defined(APLATFORM_DESKTOP)
        win::SetConsoleTextAttribute(hConsole, FOREGROUND_WHITE);
#endif
        std::cout &lt< this->version << '\n';

#if defined(APLATFORM_DESKTOP)
        win::SetConsoleTextAttribute(hConsole, FOREGROUND_YELLOW);
#endif
        //send data to be processed
        ProcessChunks(fileData + 8);

#if defined(APLATFORM_DESKTOP)
        win::SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN);
#endif
        std::cout &lt< "Load Successful!" << '\n';

        //clear memory
        delete[] fileData;
    }
    else
    {
#if defined(APLATFORM_DESKTOP)
        win::SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
#endif
        std::cout &lt< "Unable to open " << filePath << '\n';
    }
#if defined(APLATFORM_DESKTOP)
    win::SetConsoleTextAttribute(hConsole, FOREGROUND_WHITE);
#endif
}
void Model::ProcessChunks(char* bytes)
{
    //set up some utility variables
    //these are used to iterate through the data correctly
    uint32_t fileContent;
    uint32_t fileChildren;
    std::memcpy(&fileContent, bytes + 4, 4);
    std::memcpy(&fileChildren, bytes + 8, 4);
    char* endAddr = bytes + (fileContent + fileChildren + 12);
    char* addr{bytes + 12};
    //custom iterator
    //step through the block of raw bytes according to the chunk information
    while (addr &lt endAddr)
    {
        uint32_t chunkID;
        uint32_t chunkContent;
        uint32_t chunkChildren;
        std::memcpy(&chunkID, addr, 4);
        std::memcpy(&chunkContent, addr + 4, 4);
        std::memcpy(&chunkChildren, addr + 8, 4);
        char* nextAddr = addr + (chunkContent + chunkChildren + 12);

        switch (chunkID)
        {
        case ANIMDATA:
            uint32_t frameCount;
            std::memcpy(&frameCount, addr + 12, 4);
            this->frameCount = frameCount;
            break;
        case BOUNDINGBOX:
            AddFrame(addr, nextAddr);
            uint32_t nextContent;
            uint32_t nextChildren;
            std::memcpy(&nextContent, nextAddr + 4, 4);
            std::memcpy(&nextChildren, nextAddr + 8, 4);
            addr += (nextContent + nextChildren + 12);
            break;
        case RGBA:
            std::cout &lt< "Pallette Found" << '\n';
            std::memcpy(this->palette.data(), addr + 12, 1024);
            break;
        default:
            break;
        }
        addr += (chunkContent + chunkChildren + 12);
    }
    std::cout &lt< "Done processing chunks!" << '\n';
}
void Model::AddFrame(char* boundData, char* voxelData)
{
    std::cout &lt< "New frame" << '\n';
    Vector3Int bounds;
    std::memcpy(&bounds, boundData + 12, 12);
    uint32_t voxelCount;
    std::memcpy(&voxelCount, voxelData + 12, 4);
    AnimationFrame frame{};
    frame.bounds = bounds;
    frame.voxels.reserve(voxelCount);
    for (uint32_t i{0}; i &lt voxelCount; i++)
    {
        frame.voxels.push_back(
            {.x = static_cast<uint8_t>(*(voxelData + 16 + (i * 4))),
             .y = static_cast<uint8_t>(*(voxelData + 18 + (i * 4))),
             .z = static_cast<uint8_t>(*(voxelData + 17 + (i * 4))),
             .i = static_cast<uint8_t>(*(voxelData + 19 + (i * 4)))});
    }
    this->frames.push_back(std::move(frame));
}

template &ltstd::size_t N>
std::ostream& operator<<(std::ostream& os, const std::array<char, N>& data)
{
    for (uint64_t i{0}; i &lt data.size(); i++)
    {
        os &lt< data[i];
    }
    return os;
}

} //namespace vxl</code></pre>
        </div>
        <div class="tabcontent file" id="volume">
<pre><code>#include "volume.h"
#include "model.h"

#include &ltarray>
#include &ltcstdint>
#include &ltraylib.h>
#include &ltvector>

namespace vxl
{

uint8_t renderedFrames{0};

#define BOUNDINGBOX 0x455A4953
#define VOXELDATA 0x495A5958
#define ANIMDATA 0x4B434150

void DrawVolume(Model* model)
{
    Vector3Int bounds = model->frames[model->curFrame].bounds;
    for (auto voxel : model->frames[model->curFrame].voxels)
    {
        std::array<uint8_t, 4> col;
        std::memcpy(&col, &model->palette[voxel.i], 4);
        DrawCube({static_cast<float>(voxel.x - (bounds.x / 2)),
                  static_cast<float>(voxel.y - (bounds.y / 2)),
                  static_cast<float>(voxel.z - (bounds.z / 2))},
                 1.0f, 1.0f, 1.0f, {col[0], col[1], col[2], col[3]});
    }
    if (renderedFrames &lt 5)
    {
        renderedFrames++;
    }
    else
    {
        renderedFrames = 0;
        model->curFrame = (model->curFrame + 1) % model->frameCount;
    }
}

} //namespace vxl</code></pre>
        </div>
      </div>
<script>
openFirstTab("lang")
openFirstTab("file")
</script>
    </section>
  </main>
</html>
